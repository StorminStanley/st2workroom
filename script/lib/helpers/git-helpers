#!/usr/bin/env bash
set -e
set -u
set -o pipefail

# determines the type of ref based on dir and ref
#
# returns string
#
# @ git-ref-type <ref> <dir>
git-ref-type() {
    local _ref=
    local _dir=
    _ref="${1:?}"
    _dir="${2:?}"

    if git-ref-is-branch $_ref $_dir;
    then echo "branch"
    elif git-ref-is-tag $_ref $_dir;
    then echo "tag"
    else echo "unknown"
    fi
}

# determines if a git ref is a branch
#
# returns boolean
#
# @ git-ref-is-branch <ref> <dir>
git-ref-is-branch() {
    local _ref=
    local _dir=
    local _cmd=
    _ref="${1:?}"
    _dir="${2:?}"
    _cmd="git show-ref -q --verify 'refs/heads/${_ref}' 2>/dev/null;"

    pushd-quiet $_dir

    if command-successfully-run $_cmd;
    then true;
    else false;
    fi

    pushd-stepback
}

# determines if a git ref is a tag
#
# returns boolean
#
# @ git-ref-is-tag <ref> <dir>
git-ref-is-branch() {
    local _ref=
    local _dir=
    local _cmd=
    _ref="${1:?}"
    _dir="${2:?}"
    _cmd="git show-ref -q --verify 'refs/tags/${_ref}' 2>/dev/null;"

    pushd-quiet $_dir

    if command-successfully-run $_cmd;
    then true;
    else false;
    fi

    pushd-stepback
}

# safely clone a repo to a new directory by making a backup
# of a directory if it already exists
#
# @ safe-git-clone <repo> <dest> [branch]
safe-git-clone() {
    local _repo=
    local _dest_dir=
    local _branch=
    _repo="${1:?}"
    _dest_dir="${2:?}"
    _branch="${3:-master}"

    if directory-exists $_dest_dir;
    then
        safe-copy $_dest_dir "${_dest_dir}.$(current-epoch)"
        ensure-directory-absent $_dest_dir
    fi

    git-clone $_repo $_dest_dir $_branch
}

# perform a git clone with sane defaults
#
# @ git-clone <repo> <dest> [branch]
git-clone() {
    local _repo=
    local _dest_dir=
    local _branch=
    _repo="${1:?}"
    _dest_dir="${2:?}"
    _branch="${3:-master}"

    git clone $_repo $_dest_dir -b $_branch
}

# perform a git clone with no apologies. destroys anything in its path
#
# @ destructive-git-clone <repo> <dest> [branch]
destructive-git-clone() {
    local _repo=
    local _dest_dir=
    local _branch=
    _repo="${1:?}"
    _dest_dir="${2:?}"
    _branch="${3:-master}"

    ensure-directory-absent $_dest_dir
    git-clone $_repo $_dest_dir $_branch
}

# updates and cleans a git repository from upstream, and resets hard
# to clean state from upstream
#
# @ git-update-and-clean-hard <dir> [branch]
git-update-and-clean-hard() {
    local _dir=
    local _branch=
    _dir="${1:?}"
    _branch="${2:master}"

    git-update-and-clean $_dir
    git-hard-reset $_dir $_branch
}

# updates and cleans a git repository from upstream
#
# @ git-update-and-clean
git-update-and-clean() {
    pushd-quiet "${1:?}"

    git fetch --all
    git gc --auto

    pushd-stepback
}

# performs a hard reset of a git repo based on passed branch
#
# @ git-hard-reset <dir> [branch]
git-hard-reset() {
    local _dir=
    local _branch=
    _dir="${1:?}"
    _branch="${2:master}"

    pushd-quiet $_dir

    git reset --hard $_branch

    pushd-stepback
}
